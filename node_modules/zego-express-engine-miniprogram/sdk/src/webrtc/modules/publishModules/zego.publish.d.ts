import { VideoInfo, ERRO, webPublishOption, AudioMixConfig, ZegoVideoCodec, ZegoAudioContext } from "../../../common/zego.entity";
import { ZegoSignal } from "../streamSignal";
import { AudioMix } from "../../../util/audioMix";
import { PitchUtil } from "../../../util/pitchUtil";
import { ZegoStreamCenterWeb } from "../zego.streamCenter.web";
import { StateCenter } from "../../../common/stateCenter";
import { ZegoLogger, ZegoDataReport } from "../../../common/zego.entity";
import { ZegoPreview } from "./zego.preview";
export declare class ZegoPublish {
    logger: ZegoLogger;
    signal: ZegoSignal;
    state: number;
    streamCenter: ZegoStreamCenterWeb;
    sessionId: number;
    sessionToken: string;
    candidateInfo: never[];
    qualityTimer: any;
    qualityTimeInterval: number;
    publishQualityList: never[];
    maxQualityListCount: number;
    lastPublishStats: any;
    reportSeq: number;
    streamReportSeq: any;
    stateCenter: StateCenter;
    dataReport: ZegoDataReport;
    qualityUpload: boolean;
    qualityUploadInterval: number;
    qualityUploadLastTime: number;
    qualitySeq: number;
    firstGetStatsTimer: any;
    videoInfo: VideoInfo;
    mediaStreamConfig: null;
    offerSeq: number;
    streamId: string;
    localStream: MediaStream;
    ac: ZegoAudioContext;
    mediaEleSources: Array<{
        audio: HTMLMediaElement;
        node: MediaElementAudioSourceNode;
    }>;
    audioMixList: Array<{
        audioMix: AudioMix;
        media: HTMLMediaElement;
    }>;
    arrayBufferMap: {
        [index: string]: AudioMix;
    };
    effectList: Array<{
        audioMix: AudioMix;
        effectID: string;
        audioBuffer: AudioBuffer;
    }>;
    sessionSeq: number;
    peerConnection: RTCPeerConnection | null;
    qualityCount: number;
    closeSessionSignal: boolean;
    micTrack: MediaStreamTrack | null;
    pitchEffect: PitchUtil;
    channelCount: number;
    localSdpRevert: boolean;
    remoteSdpRevert: boolean;
    videoCodec: ZegoVideoCodec;
    stateNego: number;
    negoTimer: any;
    negoInterval: number;
    publishOption: webPublishOption;
    publishEvent: boolean;
    cameraState: string;
    microState: string;
    gwNode: string;
    gwNodeList: Array<string>;
    gwNodeTTL: number;
    needIncMax: boolean;
    probeCount: number;
    gotMax: boolean;
    initFitCnt: number;
    targetRate: any;
    totalBitrateArray: Array<number>;
    totalTargetRateArray: Array<number>;
    totalRetransRateArray: Array<number>;
    isPeer: boolean;
    peerFailCount: number;
    peerID: number;
    netQuality: number;
    probeTime: number;
    probeInterval: number;
    probeState: number;
    /**
     * 推流对应的 ZegoPreview 预览对象
     */
    get previewer(): ZegoPreview | null;
    constructor(log: ZegoLogger, dataReport: ZegoDataReport, qualityTimeInterval: number, streamCenter: ZegoStreamCenterWeb, ac: ZegoAudioContext, mediaEleSources: Array<{
        audio: HTMLMediaElement;
        node: MediaElementAudioSourceNode;
    }>, stateCenter: StateCenter);
    private publishStateUpdateError;
    resetPublish(): void;
    private clearPublishQualityTimer;
    shouldSendCloseSession(): boolean;
    startPublish(streamId: string, localStream: MediaStream, videoInfo: VideoInfo, mediaStreamConfig: any, publishOption?: webPublishOption): void;
    activateSEIInsert(action: 0 | 1, infoType: number): Promise<boolean>;
    private createSession;
    private handleCreateSessionResp;
    private handleCreateSessionWithSdpResp;
    private onCreatePublishSessionSuccess;
    private createOffer;
    private onCreateOfferSuccess;
    private updateBandwidthRestriction;
    private onSetLocalDescriptionSuccess;
    private onRecvMediaDescription;
    private onGetRemoteOfferSuccess;
    private onIceConnectionStateChange;
    private onIceCandidate;
    private sendCandidateInfo;
    private onConnectionStateChange;
    private onRecvCandidateInfo;
    private onRecvCloseSession;
    private onRecvResetSession;
    private onRecvPublishEvent;
    private onRecvClientInfo;
    private checkPublishConnectionFailedState;
    setPublishQualityTimer(): void;
    private peerConnectionGetStats;
    private getPublishStats;
    private uploadPublishQuality;
    stopPublish(): void;
    onPublishStateUpdate(type: number, streamId: string | null, error?: ERRO, stopRetry?: boolean): void;
    onPublishQualityUpdate(streamId: string | null, quality: any, promiseresults: any, callbackresults: any): void;
    onDisconnect(): void;
    /**
     * 播放音效
     * @param AudioMixConfig
     * @param audioBuffer
     * @param start
     * @param end
     * @returns
     */
    playEffect(AudioMixConfig: AudioMixConfig, audioBuffer: AudioBuffer, start?: Function, end?: Function): void;
    /**
     * 停止音效
     * @param effectID
     * @returns
     */
    pauseEffect(effectID?: string): boolean;
    resumeEffect(effectID?: string): boolean;
    stopEffect(effectID?: string): boolean;
    setEffectVolume(volume: number, effectID?: string): boolean;
    startMixingAudio(mediaList: Array<HTMLMediaElement>): boolean;
    stopMixingAudio(media?: Array<HTMLMediaElement>): boolean;
    mixingBuffer(sourceID: string, arrayBuffer: ArrayBuffer, callBack?: Function): void;
    stopMixingBuffer(sourceID?: string): boolean;
    setMixingAudioVolume(volume: number, audio: HTMLMediaElement): boolean;
    publishSuccess(): void;
    startSoundLevel(): void;
    stopSoundLevel(): void;
    rebackMic(): void;
    handleEncBitrate(targetEncBitrate: number, actEncBitrate: number, retransBitrate: number): void;
    resetEncBitrate(): void;
}
