import { webPlayOption, AudioMixConfig, Constraints, CapabilityDetection, CapabilityDetectionSingle, webPublishOption, PublishStreamConstraints, WebListener, MixStreamAdvance, MixStreamConfig, ZegoMediaElement, MediaRecorder, ZegoAudioContext, ZegoResponse, ZegoCheckSingleType, ZegoActivateSEIOption, StreamInfo, ZegoExpressWebRTM } from "../common/zego.entity";
import { StateCenter } from "../common/stateCenter";
import { ZegoLogger, ZegoDataReport } from "../common/zego.entity";
import { RTCModules } from "./modules";
import { ZegoStreamCenterWeb } from "./modules/zego.streamCenter.web";
export declare class ZegoWebRTC {
    stateCenter: StateCenter;
    private logger;
    private dataReport;
    private RTM;
    rtcModules: RTCModules;
    ac: ZegoAudioContext;
    mediaEleSources: Array<{
        audio: HTMLMediaElement;
        node: MediaElementAudioSourceNode;
    }>;
    streamCenter: ZegoStreamCenterWeb;
    constructor(logger: ZegoLogger, dataReport: ZegoDataReport, rtm: ZegoExpressWebRTM, ENV?: number);
    static screenShotReady: boolean;
    static mediaRecorder: MediaRecorder;
    static recordedBlobs: Blob[];
    mutePublishStreamVideo(localStream: MediaStream, mute: boolean, retain?: boolean): boolean;
    mutePublishStreamAudio(localStream: MediaStream, mute: boolean): boolean;
    mutePlayStreamVideo(streamID: string, mute: boolean): Promise<boolean>;
    mutePlayStreamAudio(streamID: string, mute: boolean): Promise<boolean>;
    muteMicrophone(mute: boolean): boolean;
    isMicrophoneMuted(): boolean;
    setAudioOutput(localVideo: HTMLMediaElement, audioOutput: string): boolean;
    setCustomSignalUrl(signalUrl: Array<string>): void;
    setQualityMonitorCycle(timeInMs: number): boolean;
    startPlayingStream(streamID: string, playOption?: webPlayOption): Promise<MediaStream>;
    stopPlayingStream(streamID: string): void;
    setTurnOverTcpOnly(bool: boolean): void;
    createStream(option?: Constraints): Promise<MediaStream>;
    destroyStream(localStream: MediaStream): void;
    startPublishingStream(streamID: string, localStream: MediaStream, publishOption?: webPublishOption): boolean;
    activateSEIInsert(config: ZegoActivateSEIOption): boolean;
    stopPublishingStream(streamID: string): boolean;
    setVideoConfig(localStream: MediaStream, constraints: PublishStreamConstraints): Promise<{
        errorCode: number;
        extendedData: string;
    }>;
    setAudioConfig(localStream: MediaStream, constraints: PublishStreamConstraints): Promise<{
        errorCode: number;
        extendedData: string;
    }>;
    replaceTrack(localStream: MediaStream, mediaStreamTrack: MediaStreamTrack): Promise<{
        errorCode: number;
        extendedData: string;
    }>;
    preloadEffect(id: string, effectUrl: string, callBack?: Function): void;
    playEffect(audioMixConfig: AudioMixConfig, start?: Function, end?: Function): void;
    pauseEffect(streamID: string, effectID?: string): boolean;
    resumeEffect(streamID: string, effectID?: string): boolean;
    stopEffect(streamID: string, effectID?: string): boolean;
    unloadEffect(effecId: string): boolean;
    setEffectVolume(streamID: string, volume: number, effectID?: string): boolean;
    startMixingAudio(streamID: string, audio: Array<HTMLMediaElement>): boolean;
    stopMixingAudio(streamID: string, audio?: Array<HTMLMediaElement>): boolean;
    mixingBuffer(streamID: string, sourceID: string, arrayBuffer: ArrayBuffer, callBack?: Function): void;
    stopMixingBuffer(streamID: string, sourceID: string): boolean;
    setMixingAudioVolume(streamID: string, volume: number, audio: HTMLMediaElement): boolean;
    checkSystemRequirements(checkLevel: 0 | 1, type?: ZegoCheckSingleType): Promise<CapabilityDetection | CapabilityDetectionSingle>;
    enumDevices(): Promise<{
        microphones: Array<{
            deviceName: string;
            deviceID: string;
        }>;
        speakers: Array<{
            deviceName: string;
            deviceID: string;
        }>;
        cameras: Array<{
            deviceName: string;
            deviceID: string;
        }>;
    }>;
    getAudioInfo(localStream: MediaStream, errCallBack: (param: any) => void, option?: {
        type: string;
        bufferSize?: number;
        channels?: number;
        sampleBit?: 8 | 16;
        sampleRate: number;
    }): any;
    getSoundLevel(localStream: MediaStream, sucCallBack: Function, errCallBack: Function): void;
    stopSoundLevel(localStream: MediaStream): void;
    private static handleDataAvailable;
    startRecord(el: ZegoMediaElement): void;
    stopRecord(): void;
    resumeRecord(): void;
    pauseRecord(): void;
    saveRecord(name: string): void;
    takeSnapShot(el: HTMLVideoElement, img: HTMLImageElement): void;
    saveSnapShot(el: HTMLVideoElement, name: string): void;
    useVideoDevice(localStream: MediaStream, deviceID: string): Promise<ZegoResponse>;
    useAudioDevice(localStream: MediaStream, deviceID: string): Promise<ZegoResponse>;
    setSoundLevelDelegate(bool: boolean, timeInMs?: number): void;
    on<k extends keyof WebListener>(event: k, callBack: WebListener[k]): boolean;
    off<k extends keyof WebListener>(event: k, callBack?: WebListener[k]): boolean;
    getVersion(): string;
    setStreamExtraInfo(streamID: string, extraInfo: string): Promise<ZegoResponse>;
    addPublishCdnUrl(streamID: string, targetURL: string): Promise<ZegoResponse>;
    removePublishCdnUrl(streamID: string, targetURL: string): Promise<ZegoResponse>;
    startMixerTask(mixStreamConfig: MixStreamConfig): Promise<{
        errorCode: number;
        extendedData: string;
    }>;
    setMixerTaskConfig(config: MixStreamAdvance): Promise<ZegoResponse>;
    stopMixerTask(taskId: string): Promise<ZegoResponse>;
    setCaptureVolume(localStream: MediaStream, volume: number): Promise<ZegoResponse>;
    getRoomInfo(): Promise<{
        streamList: StreamInfo[];
    }>;
}
