import { CapabilityDetection, CapabilityDetectionSingle, SupportVideoCodeSucCall, ERRO, Constraints, ZegoCheckSingleType } from "../common/zego.entity";
import { ZegoDataReport } from "../common/zego.entity";
export declare class ClientUtil {
    static checkIllegalCharacters(str: string): boolean;
    static isUrl(str: string): boolean;
    static registerCallback(fName: string, option: {
        success?: Function;
        error?: Function;
    }, callbackList: {
        [index: string]: Function;
    }): void;
    static actionErrorCallback(fName: string, callbackList: {
        [index: string]: Function;
    }): Function;
    static actionSuccessCallback(fName: string, callbackList: {
        [index: string]: Function;
    }): Function;
    static logReportCallback(logEvent: string, dataReport: ZegoDataReport, reportSeq: number, callbackList: {
        [index: string]: Function;
    }): void;
    static actionLogReportCallback(logEvent: string, callbackList: {
        [index: string]: Function;
    }, reportAction: string, eventName: string, args?: any): void;
    static getServerError(code: number): ERRO;
    static unregisterCallback(fName: string, callbackList: {
        [index: string]: Function;
    }): void;
    static decodeServerError(code: number, msg: string): {
        code: number;
        message: string;
    };
    static getLiveRoomError(code: number): string;
    static mixServerError(code: number): string;
    static getKickoutError(code: number): any;
    static dataReportEvent(dataReport: ZegoDataReport, reportSeq: number, reportName: string, eventName: string, args: any): void;
    static isKeepTryLogin(code: number): boolean;
    static mergeStreamList(idName: string, oldStreamList: any[], newStreamList: any[], callbackResult: {
        (addStreamList: any[], delStreamList: any[], updateStreamList: any[]): void;
        (arg0: any[], arg1: any[], arg2: any[]): void;
    }): void;
    static checkInteger(num: number | undefined, positive?: boolean): boolean;
    static checkValidNumber(param: number, min?: number, max?: number): boolean;
    static uuid(len?: number, radix?: number): string;
    static supportDetection(screenShotReady: boolean, success: (result: CapabilityDetection | CapabilityDetectionSingle) => void, checkLevel: 0 | 1, type?: ZegoCheckSingleType): Promise<void>;
    static getDevices(deviceInfoCallback: (res: {
        microphones: Array<{
            deviceName: string;
            deviceID: string;
        }>;
        speakers: Array<{
            deviceName: string;
            deviceID: string;
        }>;
        cameras: Array<{
            deviceName: string;
            deviceID: string;
        }>;
    }) => void, error: (err: ERRO) => void): void;
    static compareVersion(v1: string[] | string, v2: string | string[]): 1 | 0 | -1;
    static isSupportLive(sucCall: (arg0: {
        code: number;
        msg: string;
    }) => void, errCall: (arg0: any) => void): void;
    static supportVideoCodeType(sucCall: SupportVideoCodeSucCall, checkLevel: 0 | 1, type?: "webRTC" | "VP8" | "H264" | "newWay"): Promise<void>;
    static inlineWorker(func: Function): Worker | null;
    static getBrowser(): string;
    static getPublisherStateType(type: 0 | 1 | 2): string;
    static getPlayerStateType(type: 0 | 1 | 2): string;
    static getSteamUpdateType(type: 0 | 1): string;
    static checkScreenParams(screen: Constraints["screen"], errorCallback: Function): boolean;
    static checkCameraParams(cameras: {
        width?: number;
        height?: number;
        frameRate?: number;
        bitRate?: number;
    }, errorCallback: Function): boolean;
    static isParamEmpty(param: any): boolean;
    static isTypeString(param: any): boolean;
    static isTooLong(param: string, len: number): boolean;
    static isReDispatch(error: ERRO): boolean;
    static arrAvg(arr: Array<number>, val: any, shiftLen: number): any;
    static getNetQuality(rtt: number, lostRate: number, jitter?: number): number;
    static calcQualityOfRtt(rtt: number): number;
    static calcQualityOfJitter(jitter: number): number;
    static calcQualityOfLostRate(lostRate: number, isProbe: boolean): number;
    static quality2QualityGrade(quality: number): number;
}
